<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Wargame Map (Critically Appraised)</title>

    <!-- Leaflet.js CSS for map styling -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""/>

    <!-- Tailwind CSS for overall page styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrolling */
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        #map {
            height: 100%;
            width: 100%;
            background-color: #a2d3f5; /* A light blue to represent the sea/sky */
        }
        /* Styling for the unit name labels */
        .unit-label {
            font-size: 10px;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
            color: #1f2937; /* gray-800 */
            text-shadow: 0 0 2px white, 0 0 2px white, 0 0 2px white;
        }
        /* Style for draggable items in the menu */
        .draggable-unit { cursor: grab; }
        .draggable-unit:active { cursor: grabbing; }
        /* Style for mountable ordnance in the menu */
        .mountable-ordnance { background-color: #eef2ff; }
        /* Cursors for different modes */
        .targeting-cursor { cursor: crosshair !important; }
        .move-cursor { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>') 16 16, auto !important; }
        .targeting-cursor .leaflet-marker-icon.invalid-target-hover,
        .move-cursor .leaflet-marker-icon { cursor: not-allowed !important; }
        /* Line styles */
        .trajectory-line, .move-path-line { stroke-dasharray: 5, 10; }
        .jamming-circle-pulse { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { stroke-opacity: 1; stroke-width: 2; }
            50% { stroke-opacity: 0.5; stroke-width: 4; }
            100% { stroke-opacity: 1; stroke-width: 2; }
        }
        /* Jammed unit effect */
        .jammed-effect {
            animation: flicker 0.3s infinite;
        }
        @keyframes flicker {
            0% { filter: grayscale(1) opacity(0.7); }
            50% { filter: grayscale(1) opacity(0.4); }
            100% { filter: grayscale(1) opacity(0.7); }
        }
        /* Targeting button effect */
        .targeting-button-pulse {
            animation: pulse-bg 1.5s infinite;
        }
        @keyframes pulse-bg {
            0% { background-color: #f59e0b; } /* amber-500 */
            50% { background-color: #fcd34d; } /* amber-300 */
            100% { background-color: #f59e0b; } /* amber-500 */
        }
        /* Aircraft weapon badge */
        .weapon-badge {
            position: absolute; top: -5px; right: -8px;
            background-color: #ef4444; color: white;
            border-radius: 9999px; width: 18px; height: 18px;
            font-size: 11px; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            border: 2px solid white;
        }
        /* Highlight for valid drop target */
        .drop-target-highlight { filter: drop-shadow(0 0 8px #22c55e) !important; }
        
        /* NEW: Targeting Panel styles */
        #targeting-panel {
            transition: transform 0.3s ease-in-out;
        }

        /* NEW: Legend Styles */
        .legend {
            padding: 6px 8px;
            font: 12px/1.5 'Inter', sans-serif;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        .legend h4 {
            margin: 0 0 5px;
            color: #333;
            font-weight: 700;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        
        /* REWORK: Contemporary popup style for info */
        .unit-info-popup .leaflet-popup-content-wrapper {
            background-color: rgba(255, 255, 255, 0.95) !important;
            border-radius: 8px !important;
            border: 1px solid #ccc !important;
            box-shadow: 0 3px 15px rgba(0,0,0,0.2) !important;
        }
        .unit-info-popup .leaflet-popup-content {
            margin: 12px;
            font-size: 13px;
            line-height: 1.6;
        }
        .unit-info-popup .leaflet-popup-tip-container {
            display: none;
        }

        /* NEW: Style for dynamic ring labels */
        .ring-label {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="flex h-screen">
        <!-- Map Container -->
        <div id="map-container" class="relative flex-grow h-full">
            <div id="map"></div>
            <!-- Simulation Controls -->
            <div class="absolute top-4 left-4 z-[1000] bg-white p-2 rounded-lg shadow-lg flex flex-col space-y-2">
                <div class="flex space-x-2">
                    <button id="targeting-btn" class="flex-1 px-3 py-2 text-sm font-medium text-white bg-gray-600 rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">Targeting Mode</button>
                    <button id="launch-btn" class="flex-1 px-3 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">Launch Missiles</button>
                </div>
                <div class="flex space-x-2">
                    <button id="save-btn" class="flex-1 px-3 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">Save State</button>
                    <button id="reset-btn" class="flex-1 px-3 py-2 text-sm font-medium text-white bg-orange-500 rounded-md hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-400">Reset Scene</button>
                    <button id="clear-btn" class="flex-1 px-3 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">Clear All</button>
                </div>
            </div>
            
            <!-- NEW: Targeting Control Panel -->
            <div id="targeting-panel" class="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-full w-full max-w-4xl bg-gray-800/90 text-white p-4 rounded-t-lg shadow-2xl z-[1000]">
                <div id="targeting-panel-content" class="text-center"></div>
            </div>
        </div>

        <!-- Right Hand Menu -->
        <div class="w-80 h-full bg-white shadow-lg overflow-y-auto p-4 border-l border-gray-200">
            <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">Entity Library</h2>
            <div id="unit-menu" class="space-y-4">
                <!-- Menu content will be generated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Leaflet.js JavaScript library -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""></script>

    <script>
        // --- GLOBAL STATE ---
        var activeAction = { type: null, armedUnit: null, armedWeapon: null, shotsToFire: 0 };
        var activeMapUnits = new Map();
        var savedScenario = null;
        var nextUnitInstanceId = 0;
        var lastFrameTime = performance.now();
        var activeInfoPopup = null; 

        // --- MAP INITIALIZATION ---
        var map = L.map('map').setView([-6.3, 146.8], 5);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // --- VISUAL CONFIGURATION ---
        const ringStyles = {
            sensor: { color: '#0ea5e9', weight: 1.5, dashArray: '2, 8', fillOpacity: 0.05 }, // Cyan
            movement: { color: '#22c55e', weight: 1.5, dashArray: '10, 10', fillOpacity: 0.05 }, // Green
            ea: { color: '#a855f7', weight: 2, className: 'jamming-circle-pulse', fillOpacity: 0.1 }, // Purple
            weapon: { color: '#ef4444', weight: 2, dashArray: null, fillOpacity: 0.1 } // Red
        };

        // --- UNIT DATA LIBRARY ---
        // REWORK: Simplified weapon rings to a single max range.
        const unitLibrary = {
            // Red Force
            'sa-10': { name: 'SA-10 Shawshank', shortName: 'SA-10', force: 'red', category: 'weapons', iconUrl: 'https://cdn-icons-png.flaticon.com/512/7165/7165074.png', ammo: 4, movable: true, speedKph: 50, c4Dependent: true,
                rangeRings: [
                    { type: 'sensor', rangeNm: 150, name: 'Sensor Range' },
                    { type: 'weapon', rangeNm: 120, name: 'Weapon Range' }
                ]
            },
            'sa-12': { name: 'SA-12 Sabot', shortName: 'SA-12', force: 'red', category: 'weapons', iconUrl: 'https://cdn-icons-png.flaticon.com/512/7165/7165074.png', ammo: 4, movable: true, speedKph: 50, c4Dependent: true,
                rangeRings: [
                    { type: 'sensor', rangeNm: 350, name: 'Sensor Range' },
                    { type: 'weapon', rangeNm: 300, name: 'Weapon Range' }
                ]
            },
            'anti-ship': { name: 'Anti-Ship Missile', shortName: 'CD Missile', force: 'red', category: 'weapons', iconUrl: 'https://cdn-icons-png.flaticon.com/512/2369/2369415.png', ammo: 2, movable: true, speedKph: 40, c4Dependent: true,
                rangeRings: [
                    { type: 'weapon', rangeNm: 350, name: 'Weapon Range' }
                ]
            },
            'marines': { name: 'Marines', shortName: 'Marines', force: 'red', category: 'land', iconUrl: 'https://cdn-icons-png.flaticon.com/512/9924/9924283.png',
                rangeRings: [
                    { type: 'sensor', rangeNm: 50, name: 'Engagement Zone' }
                ]
            },
            'y-12': { name: 'Y-12 Milo', shortName: 'Y-12', force: 'red', category: 'air', platformType: 'air', iconUrl: 'https://cdn-icons-png.flaticon.com/512/7893/7893970.png', hardpoints: 2, c4Dependent: true,
                rangeRings: [
                    { type: 'sensor', rangeNm: 200, name: 'Sensor Range' }
                ]
            },
            
            // Blue Force
            'agm-258': { name: 'AGM-258 JASSM', shortName: 'JASSM', force: 'blue', category: 'weapons', platform: 'aircraft', iconUrl: 'https://cdn-icons-png.flaticon.com/512/7165/7165074.png', ammo: 1,
                rangeRings: [ { type: 'weapon', rangeNm: 200, name: 'Weapon Range' } ]
            },
            'meteor': { name: 'Meteor BVRAAM', shortName: 'Meteor', force: 'blue', category: 'weapons', platform: 'aircraft', iconUrl: 'https://cdn-icons-png.flaticon.com/512/2369/2369415.png', ammo: 1,
                rangeRings: [ { type: 'weapon', rangeNm: 100, name: 'Weapon Range' } ]
            },
            'blue-hq': { name: 'Blue Joint HQ', shortName: 'Joint HQ', force: 'blue', category: 'land', iconUrl: 'https://cdn-icons-png.flaticon.com/512/208/208379.png', rangeRings: [] },
            'wedge-snail': { name: 'Wedge-Snail', shortName: 'Wedge-Snail', force: 'blue', category: 'air', platformType: 'air', iconUrl: 'https://cdn-icons-png.flaticon.com/512/7893/7893970.png', hardpoints: 4,
                rangeRings: [
                    { type: 'sensor', rangeNm: 2000, name: 'AEW&C Radar' }
                ]
            },
            'ea-30g': { name: 'EA-30G Fowler', shortName: 'EA-30G', force: 'blue', category: 'air', platformType: 'air', iconUrl: 'https://cdn-icons-png.flaticon.com/512/15631/15631307.png', hardpoints: 4, role: 'Electronic Attack', eaRangeNm: 400,
                rangeRings: [
                    { type: 'ea', rangeNm: 400, name: 'Jamming Radius' }
                ]
            },
            'f-55': { name: 'F-55 Flogger', shortName: 'F-55', force: 'blue', category: 'air', platformType: 'air', iconUrl: 'https://cdn-icons-png.flaticon.com/512/2089/2089910.png', hardpoints: 6,
                rangeRings: [
                    { type: 'sensor', rangeNm: 800, name: 'Sensor Range' }
                ]
            }
        };
        const impactIconUrl = 'https://cdn-icons-png.flaticon.com/512/3219/3219507.png';
        const missedIconUrl = 'https://cdn-icons-png.flaticon.com/512/14521/14521298.png';
        const NM_TO_METERS = 1852;
        const KPH_TO_MPS = 1000 / 3600;

        // --- UTILITY & ICON CREATION ---
        const createUrlIcon = (url, size = [32, 32]) => L.icon({ iconUrl: url, iconSize: size, iconAnchor: [size[0]/2, size[1]], popupAnchor: [0, -size[1]] });
        
        function createAircraftIcon(unitData, weaponCount) {
            const badgeHtml = weaponCount > 0 ? `<div class="weapon-badge">${weaponCount}</div>` : '';
            return L.divIcon({
                className: 'custom-div-icon',
                html: `<div style="position: relative;"><img src="${unitData.iconUrl}" style="width: 32px; height: 32px;">${badgeHtml}</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32]
            });
        }

        // --- CORE UNIT MANAGEMENT ---
        function addCapability(latlng, unitId, instanceId = null, ammo = null, mountedWeapons = null, destination = null) {
            const unitData = unitLibrary[unitId];
            if (!unitData) return;

            const currentInstanceId = instanceId !== null ? instanceId : nextUnitInstanceId++;
            const icon = unitData.platformType === 'air' ? createAircraftIcon(unitData, mountedWeapons ? mountedWeapons.length : 0) : createUrlIcon(unitData.iconUrl);
            const marker = L.marker(latlng, { icon, draggable: true }).addTo(map);
            marker.instanceId = currentInstanceId;

            const nameMarker = L.marker(latlng, {
                icon: L.divIcon({ className: 'unit-label', html: `<div>${unitData.shortName}</div>`, iconAnchor: [unitData.shortName.length * 3, -5] }),
                interactive: false
            }).addTo(map);

            const unitObject = {
                marker, nameMarker, rangeCircles: [], unitId, unitData,
                instanceId: currentInstanceId,
                ammo: ammo !== null ? ammo : unitData.ammo,
                pendingTargets: [], 
                mountedWeapons: unitData.hardpoints ? (mountedWeapons || []).map(w => ({ ...w, rangeCircles: [], pendingTargets: [] })) : null,
                destination: destination ? L.latLng(destination.lat, destination.lng) : null,
                movePathLine: null,
                isJammed: false,
                jammingCircle: null,
                ringLabels: []
            };
            
            (unitData.rangeRings || []).forEach(ringInfo => {
                const style = ringStyles[ringInfo.type];
                if (style) {
                    const circle = L.circle(latlng, {
                        radius: ringInfo.rangeNm * NM_TO_METERS,
                        ...style,
                        // Store original style for hover effect
                        originalStyle: style
                    });
                    circle.ringInfo = ringInfo; // Attach info to the circle itself
                    unitObject.rangeCircles.push(circle);
                }
            });
            unitObject.rangeCircles.forEach(c => c.addTo(map));

            activeMapUnits.set(currentInstanceId, unitObject);
            
            if (unitObject.destination) {
                unitObject.movePathLine = L.polyline([marker.getLatLng(), unitObject.destination], { color: 'green', weight: 2, className: 'move-path-line' }).addTo(map);
            }

            bindUnitEvents(unitObject);
            return unitObject;
        }

        function deleteUnit(instanceId) {
            const unitToRemove = activeMapUnits.get(instanceId);
            if (unitToRemove) {
                map.closePopup();
                unitToRemove.marker.remove();
                unitToRemove.nameMarker.remove();
                unitToRemove.rangeCircles.forEach(c => c.remove());
                if (unitToRemove.movePathLine) unitToRemove.movePathLine.remove();
                unitToRemove.pendingTargets?.forEach(t => t.line.remove());
                activeMapUnits.delete(instanceId);
            }
        }

        function updateUnitPosition(unit, newLatLng) {
            unit.marker.setLatLng(newLatLng);
            unit.nameMarker.setLatLng(newLatLng);
            unit.rangeCircles.forEach(circle => circle.setLatLng(newLatLng));
            if (unit.movePathLine) {
                unit.movePathLine.setLatLngs([newLatLng, unit.destination]);
            }
        }

        function bindUnitEvents(unitObject) {
            const { marker, unitData } = unitObject;

            marker.on('dragstart', () => {
                map.closePopup();
            });

            marker.on('drag', e => {
                const currentUnit = activeMapUnits.get(e.target.instanceId);
                if (!currentUnit) return;
                
                currentUnit.destination = null; 
                if (currentUnit.movePathLine) {
                    currentUnit.movePathLine.remove();
                    currentUnit.movePathLine = null;
                }
                updateUnitPosition(currentUnit, e.latlng);
            });
            
            marker.on('dragend', function() {
                const markerElement = this.getElement();
                if (markerElement && markerElement.matches(':hover')) {
                    this.fire('click', { latlng: this.getLatLng() });
                }
            });

            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                
                if (activeAction.type === 'targeting') {
                    if (activeAction.armedWeapon) {
                        setTarget(unitObject);
                    } else {
                        selectUnitForTargeting(unitObject);
                    }
                } else {
                    if (activeInfoPopup && activeInfoPopup._source === marker) {
                        map.closePopup(activeInfoPopup);
                        activeInfoPopup = null;
                    } else {
                        if(activeInfoPopup) map.closePopup(activeInfoPopup);
                        activeInfoPopup = L.popup({
                                closeButton: false,
                                className: 'unit-info-popup',
                                offset: [20, -15]
                            })
                            .setLatLng(marker.getLatLng())
                            .setContent(getUnitInfoPopupHTML(unitObject));
                        
                        marker.bindPopup(activeInfoPopup).openPopup();
                    }
                }
            });
            
            // REWORK: New hover logic for dynamic ring labels
            marker.on('mouseover', () => {
                if (activeAction.type) return;
                unitObject.rangeCircles.forEach(circle => {
                    circle.setStyle({ weight: 3, opacity: 1 });
                    const point = getPointOnCircle(circle.getLatLng(), circle.getRadius());
                    const label = L.marker(point, {
                        icon: L.divIcon({
                            className: 'ring-label',
                            html: `<span>${circle.ringInfo.name}</span>`
                        }),
                        interactive: false
                    }).addTo(map);
                    unitObject.ringLabels.push(label);
                });
            });

            marker.on('mouseout', () => {
                if (activeAction.type) return;
                unitObject.rangeCircles.forEach(circle => {
                    circle.setStyle(circle.options.originalStyle);
                });
                unitObject.ringLabels.forEach(label => label.remove());
                unitObject.ringLabels = [];
            });

            if (unitData.platformType === 'air') {
                const el = marker.getElement();
                if (el) {
                    el.addEventListener('dragenter', e => { e.preventDefault(); el.classList.add('drop-target-highlight'); });
                    el.addEventListener('dragleave', e => { e.preventDefault(); el.classList.remove('drop-target-highlight'); });
                    el.addEventListener('dragover', e => e.preventDefault());
                    el.addEventListener('drop', e => {
                        e.preventDefault();
                        el.classList.remove('drop-target-highlight');
                        mountWeaponOnAircraft(unitObject, e.dataTransfer.getData('text/plain'));
                    });
                }
            }
        }
        
        function getUnitInfoPopupHTML(unitObject) {
            const { unitData, instanceId } = unitObject;
            let html = `<div class="p-1">
                <h3 class="text-base font-bold text-gray-800">${unitData.name}</h3>
                <p><b>Force:</b> <span class="capitalize ${unitData.force === 'red' ? 'text-red-600' : 'text-blue-600'}">${unitData.force}</span></p>`;
            
            if (unitData.platformType === 'air') {
                html += `<p><b>Hardpoints:</b> ${unitObject.mountedWeapons.length} / ${unitData.hardpoints}</p>`;
                if (unitObject.mountedWeapons.length > 0) {
                    html += `<div class="border-t pt-1 mt-1 space-y-1">`;
                    unitObject.mountedWeapons.forEach(weapon => {
                        html += `<div class="flex justify-between items-center text-sm">
                            <span>${unitLibrary[weapon.weaponId].shortName}</span>
                            <button data-action="unmount" data-unit-id="${instanceId}" data-weapon-id="${weapon.instanceId}" class="text-xs text-white bg-red-600 hover:bg-red-700 rounded px-1 py-0.5">X</button>
                        </div>`;
                    });
                    html += `</div>`;
                }
            } else if (unitData.ammo !== undefined) {
                 html += `<p><b>Ammo:</b> ${unitObject.ammo}</p>`;
            }

            html += `<button data-action="delete" data-unit-id="${instanceId}" class="mt-2 w-full text-xs text-white bg-gray-700 hover:bg-gray-800 rounded py-1">Delete Unit</button></div>`;
            return html;
        }

        // --- AIRCRAFT LOADOUT LOGIC ---
        function mountWeaponOnAircraft(aircraft, weaponUnitId) {
            const weaponData = unitLibrary[weaponUnitId];
            if (!aircraft || !weaponData || weaponData.platform !== 'aircraft' || aircraft.unitData.force !== weaponData.force) return;
            if (aircraft.mountedWeapons.length >= aircraft.unitData.hardpoints) return;
            const newWeapon = { weaponId: weaponUnitId, ammo: weaponData.ammo, instanceId: nextUnitInstanceId++, pendingTargets: [], rangeCircles: [] };
            const aircraftLatLng = aircraft.marker.getLatLng();
            newWeapon.rangeCircles = (weaponData.rangeRings || []).map(r => L.circle(aircraftLatLng, { radius: r.rangeNm * NM_TO_METERS, ...ringStyles.weapon }).addTo(map));
            aircraft.mountedWeapons.push(newWeapon);
            aircraft.rangeCircles.push(...newWeapon.rangeCircles);
            aircraft.marker.setIcon(createAircraftIcon(aircraft.unitData, aircraft.mountedWeapons.length));
        }
        
        function unmountWeaponFromAircraft(aircraftInstanceId, weaponInstanceId) {
            const aircraft = activeMapUnits.get(aircraftInstanceId);
            if (!aircraft || !aircraft.mountedWeapons) return;
            const weaponIndex = aircraft.mountedWeapons.findIndex(w => w.instanceId === weaponInstanceId);
            if (weaponIndex > -1) {
                const [removedWeapon] = aircraft.mountedWeapons.splice(weaponIndex, 1);
                
                if (removedWeapon.rangeCircles) {
                    removedWeapon.rangeCircles.forEach(c => c.remove());
                    aircraft.rangeCircles = aircraft.rangeCircles.filter(c => !removedWeapon.rangeCircles.includes(c));
                }

                aircraft.marker.setIcon(createAircraftIcon(aircraft.unitData, aircraft.mountedWeapons.length));
                map.closePopup();
            }
        }

        // --- ACTION & TARGETING LOGIC ---
        function setAction(type) {
            const mapContainer = document.getElementById('map-container');
            const targetingBtn = document.getElementById('targeting-btn');
            const targetingPanel = document.getElementById('targeting-panel');

            if (activeAction.armedUnit) {
                const el = activeAction.armedUnit.marker.getElement();
                if (el) el.style.filter = '';
            }
            activeAction.armedUnit = null;
            activeAction.armedWeapon = null;
            activeAction.shotsToFire = 0;

            activeAction.type = type;

            if (type === 'targeting') {
                map.closePopup();
                mapContainer.classList.add('targeting-cursor');
                targetingBtn.textContent = 'Cancel Targeting';
                targetingBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                targetingBtn.classList.add('bg-amber-600', 'hover:bg-amber-700');
                targetingPanel.style.transform = 'translateY(0)';
                updateTargetingPanel();
            } else {
                mapContainer.classList.remove('targeting-cursor', 'move-cursor');
                targetingBtn.textContent = 'Targeting Mode';
                targetingBtn.classList.remove('bg-amber-600', 'hover:bg-amber-700');
                targetingBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                targetingPanel.style.transform = 'translateY(100%)';
            }
        }

        function selectUnitForTargeting(unit) {
            if (!unit || unit.isJammed) return;
            const hasWeapons = (unit.unitData.category === 'weapons' && (unit.ammo - unit.pendingTargets.length) > 0) || (unit.mountedWeapons && unit.mountedWeapons.some(w => (w.ammo - w.pendingTargets.length) > 0));
            if (!hasWeapons) return;

            if (activeAction.armedUnit) {
                const el = activeAction.armedUnit.marker.getElement();
                if (el) el.style.filter = '';
            }
            
            activeAction.armedUnit = unit;
            activeAction.armedWeapon = null;
            activeAction.shotsToFire = 0;

            const el = unit.marker.getElement();
            if (el) el.style.filter = 'drop-shadow(0 0 8px #2563eb)';

            updateTargetingPanel();
        }

        function armWeapon(weapon) {
            activeAction.armedWeapon = weapon;
            activeAction.shotsToFire = weapon.ammo - weapon.pendingTargets.length;
            
            const el = activeAction.armedUnit.marker.getElement();
            if (el) el.style.filter = 'drop-shadow(0 0 8px #f59e0b)';
            updateTargetingPanel();
        }

        function updateTargetingPanel() {
            const panelContent = document.getElementById('targeting-panel-content');
            panelContent.innerHTML = '';

            if (!activeAction.armedUnit) {
                panelContent.innerHTML = `<p class="font-semibold">Select an entity you wish to arm.</p>`;
                return;
            }

            const unit = activeAction.armedUnit;
            if (activeAction.armedWeapon) {
                const weaponData = unit.unitData.platformType === 'air' ? unitLibrary[activeAction.armedWeapon.weaponId] : unit.unitData;
                panelContent.innerHTML = `<p class="font-semibold">Armed: <span class="text-amber-400">${unit.unitData.name} - ${weaponData.shortName}</span>. Select a target (${activeAction.shotsToFire} shots remaining).</p>`;
                return;
            }

            const header = document.createElement('h3');
            header.className = 'text-lg font-bold mb-2';
            header.textContent = `Arming: ${unit.unitData.name}`;
            panelContent.appendChild(header);

            const weaponsList = document.createElement('div');
            weaponsList.className = 'flex justify-center items-center gap-4';
            
            if (unit.unitData.platformType === 'air') {
                if (unit.mountedWeapons.length > 0) {
                    unit.mountedWeapons.forEach(weapon => {
                        const availableAmmo = weapon.ammo - weapon.pendingTargets.length;
                        if (availableAmmo > 0) {
                            const weaponData = unitLibrary[weapon.weaponId];
                            const btn = document.createElement('button');
                            btn.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded';
                            btn.textContent = `Arm ${weaponData.shortName} (${availableAmmo})`;
                            btn.onclick = () => armWeapon(weapon);
                            weaponsList.appendChild(btn);
                        }
                    });
                }
            } else {
                const availableAmmo = unit.ammo - unit.pendingTargets.length;
                if (availableAmmo > 0) {
                    const btn = document.createElement('button');
                    btn.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded';
                    btn.textContent = `Arm ${unit.unitData.shortName} (${availableAmmo})`;
                    btn.onclick = () => armWeapon(unit);
                    weaponsList.appendChild(btn);
                }
            }
             if (weaponsList.children.length === 0) {
                weaponsList.textContent = 'No available weapons to arm.';
            }

            panelContent.appendChild(weaponsList);
        }

        function activateMoveMode(unitInstanceId) {
            setAction('move');
            const unit = activeMapUnits.get(unitInstanceId);
            if (unit && unit.unitData.movable && !unit.isJammed) {
                const el = unit.marker.getElement();
                if (el) el.style.filter = `drop-shadow(0 0 8px #16a34a)`;
                map.closePopup();
            }
        }

        function setTarget(targetUnit, mapLatLng = null) {
            const { armedWeapon, armedUnit } = activeAction;
            if (!armedWeapon || !armedUnit) return;
        
            const targetLatLng = mapLatLng || (targetUnit ? targetUnit.marker.getLatLng() : null);
            if (!targetLatLng) return;
        
            if (targetUnit && (targetUnit.instanceId === armedUnit.instanceId || targetUnit.unitData.force === armedUnit.unitData.force)) {
                return;
            }
        
            const trajectoryLine = L.polyline([armedUnit.marker.getLatLng(), targetLatLng], { color: 'red', weight: 2, className: 'trajectory-line' }).addTo(map);
            armedWeapon.pendingTargets.push({ target: targetLatLng, line: trajectoryLine });
            
            activeAction.shotsToFire--;
        
            if (activeAction.shotsToFire <= 0) {
                const el = armedUnit.marker.getElement();
                if (el) el.style.filter = '';
                activeAction.armedUnit = null;
                activeAction.armedWeapon = null;
            }
            
            updateTargetingPanel();
        }
        
        function cancelAllTargets(unit) {
            unit.pendingTargets.forEach(t => t.line.remove());
            unit.pendingTargets = [];
            if (unit.mountedWeapons) {
                unit.mountedWeapons.forEach(w => {
                    w.pendingTargets.forEach(t => t.line.remove());
                    w.pendingTargets = [];
                });
            }
        }

        // --- SIMULATION & ANIMATION ---
        function launchAllTargeted() {
            const launchesToExecute = [];
            activeMapUnits.forEach(unit => {
                if (unit.pendingTargets.length > 0) {
                    unit.pendingTargets.forEach(targetInfo => {
                        launchesToExecute.push({ unit, weapon: null, target: targetInfo.target, line: targetInfo.line });
                        unit.ammo--;
                    });
                    unit.pendingTargets = [];
                }
                if (unit.mountedWeapons) {
                    unit.mountedWeapons.forEach(weapon => {
                        if (weapon.pendingTargets.length > 0) {
                            weapon.pendingTargets.forEach(targetInfo => {
                                launchesToExecute.push({ unit, weapon, target: targetInfo.target, line: targetInfo.line });
                                weapon.ammo--;
                            });
                            weapon.pendingTargets = [];
                        }
                    });
                }
            });
            
            setAction(null);
            launchesToExecute.forEach(animateMissile);
        }

        function animateMissile(launch) {
            launch.line.remove(); // Remove the planning line
            const launcher = launch.unit;
            const weaponInstance = launch.weapon ? launch.weapon : launcher;
            const weaponData = launch.weapon ? unitLibrary[launch.weapon.weaponId] : launcher.unitData;
            
            const startPoint = launcher.marker.getLatLng();
            const maxRangeMeters = (weaponData.maxRangeNm || weaponData.rangeRings[0].rangeNm) * NM_TO_METERS;
            const isHit = startPoint.distanceTo(launch.target) <= maxRangeMeters;
            const endPoint = isHit ? launch.target : getPointAtDistance(startPoint, launch.target, maxRangeMeters);
            
            const flyingMarker = L.marker(startPoint, { icon: createUrlIcon(weaponData.iconUrl), draggable: false, interactive: false }).addTo(map);
            const duration = 3000;
            const startTime = performance.now();
            function animationStep(now) {
                const progress = Math.min((now - startTime) / duration, 1);
                flyingMarker.setLatLng(L.latLng(startPoint.lat + (endPoint.lat - startPoint.lat) * progress, startPoint.lng + (endPoint.lng - startPoint.lng) * progress));
                if (progress < 1) {
                    requestAnimationFrame(animationStep);
                } else {
                    flyingMarker.remove();
                    const resultIconUrl = isHit ? impactIconUrl : missedIconUrl;
                    const resultMarker = L.marker(endPoint, { icon: createUrlIcon(resultIconUrl, [48, 48]), interactive: false }).addTo(map);
                    setTimeout(() => {
                        resultMarker.remove();
                        const currentLauncher = activeMapUnits.get(launcher.instanceId);
                        if (currentLauncher && weaponInstance.ammo <= 0 && weaponInstance.pendingTargets.length === 0) {
                            if (launch.weapon) {
                                unmountWeaponFromAircraft(launcher.instanceId, weaponInstance.instanceId);
                            } else {
                                deleteUnit(launcher.instanceId);
                            }
                        }
                    }, 2000);
                }
            }
            requestAnimationFrame(animationStep);
        }

        function updateJammedStateVisuals(unit) {
            const el = unit.marker.getElement();
            if (el) el.classList.toggle('jammed-effect', unit.isJammed);
            const opacity = unit.isJammed ? 0.2 : 1;
            const fillOpacity = unit.isJammed ? 0.0 : 0.1;
            unit.rangeCircles.forEach(c => c.setStyle({ opacity, fillOpacity }));
        }

        function gameLoop(currentTime) {
            const timeDelta = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            const jammers = Array.from(activeMapUnits.values()).filter(u => u.unitData.role === 'Electronic Attack' && !u.isJammed);
            const jammableUnits = Array.from(activeMapUnits.values()).filter(u => u.unitData.c4Dependent);

            jammableUnits.forEach(unit => {
                const wasJammed = unit.isJammed;
                let isNowJammed = false;
                for (const jammer of jammers) {
                    if (jammer.unitData.force !== unit.unitData.force) {
                        const distance = unit.marker.getLatLng().distanceTo(jammer.marker.getLatLng());
                        if (distance <= jammer.unitData.eaRangeNm * NM_TO_METERS) {
                            isNowJammed = true;
                            break;
                        }
                    }
                }
                unit.isJammed = isNowJammed;
                if (wasJammed !== unit.isJammed) {
                    if (unit.isJammed) {
                        cancelAllTargets(unit);
                        unit.destination = null; 
                        if (unit.movePathLine) {
                            unit.movePathLine.remove();
                            unit.movePathLine = null;
                        }
                    }
                    updateJammedStateVisuals(unit);
                }
            });

            for (const unit of activeMapUnits.values()) {
                if (unit.destination && unit.unitData.movable) {
                    const currentPos = unit.marker.getLatLng();
                    const distanceToTarget = currentPos.distanceTo(unit.destination);
                    const moveDistance = (unit.unitData.speedKph * KPH_TO_MPS) * timeDelta;
                    if (distanceToTarget <= moveDistance) {
                        updateUnitPosition(unit, unit.destination);
                        unit.destination = null;
                        if (unit.movePathLine) {
                            unit.movePathLine.remove();
                            unit.movePathLine = null;
                        }
                    } else {
                        updateUnitPosition(unit, getPointAtDistance(currentPos, unit.destination, moveDistance));
                    }
                }
            }
            requestAnimationFrame(gameLoop);
        }

        function getPointAtDistance(start, end, distance) {
            const totalDist = map.distance(start, end);
            if (distance >= totalDist) return end;
            const ratio = distance / totalDist;
            return L.latLng(start.lat + (end.lat - start.lat) * ratio, start.lng + (end.lng - start.lng) * ratio);
        }
        
        // NEW: Utility to get a point on a circle's edge for labels
        function getPointOnCircle(center, radius) {
            const angle = -45 * (Math.PI / 180); // 45 degrees to the top-right
            const point = map.project(center);
            const newPoint = L.point(point.x + radius * Math.cos(angle), point.y + radius * Math.sin(angle));
            return map.unproject(newPoint);
        }

        // --- SCENE & UI MANAGEMENT ---
        function clearMap() {
            activeMapUnits.forEach((_, id) => deleteUnit(id));
            activeMapUnits.clear();
            nextUnitInstanceId = 0;
            setAction(null);
        }

        function populateMenu() {
            const menu = document.getElementById('unit-menu');
            if (!menu) return;
            menu.innerHTML = '';
            const forces = {
                red: { name: 'Red Force', color: 'red-600', categories: { weapons: [], land: [], air: [], ordnance: [] } },
                blue: { name: 'Blue Force', color: 'blue-600', categories: { weapons: [], land: [], air: [], ordnance: [] } }
            };
            for (const [unitId, unit] of Object.entries(unitLibrary)) {
                const category = unit.platform === 'aircraft' ? 'ordnance' : unit.category;
                if (forces[unit.force]?.categories[category]) {
                    forces[unit.force].categories[category].push({ ...unit, id: unitId });
                }
            }
            for (const force of Object.values(forces)) {
                const forceElement = document.createElement('details');
                forceElement.className = 'group';
                forceElement.open = true;
                let forceHtml = `<summary class="flex justify-between items-center font-semibold cursor-pointer text-lg text-${force.color} p-2 rounded-md bg-gray-50 hover:bg-gray-100">${force.name}<svg class="w-5 h-5 group-open:rotate-180 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg></summary><div class="pl-2 pt-2 space-y-3">`;
                const categoryNames = { weapons: 'Weapons Platforms', land: 'Land Force', air: 'Air Force', ordnance: 'Ordnance' };
                for (const [catKey, catName] of Object.entries(categoryNames)) {
                    const units = force.categories[catKey];
                    if (units?.length > 0) {
                        forceHtml += `<h4 class="font-semibold text-gray-600 text-sm border-b pb-1">${catName}</h4><div class="space-y-2 pl-2">`;
                        units.forEach(unit => {
                            const isOrdnance = unit.platform === 'aircraft';
                            const divClass = `draggable-unit flex items-center p-2 rounded-md hover:bg-gray-200 transition-colors ${isOrdnance ? 'mountable-ordnance' : ''}`;
                            forceHtml += `<div class="${divClass}" draggable="true" data-unit-id="${unit.id}"><img src="${unit.iconUrl}" class="w-6 h-6 mr-3"><span class="text-sm text-gray-700">${unit.name}</span></div>`;
                        });
                        forceHtml += `</div>`;
                    }
                }
                forceHtml += `</div>`;
                forceElement.innerHTML = forceHtml;
                menu.appendChild(forceElement);
            }
            document.querySelectorAll('.draggable-unit').forEach(item => {
                item.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', e.target.closest('.draggable-unit').dataset.unitId);
                    e.dataTransfer.effectAllowed = 'copy';
                });
            });
        }


        function setupInitialScene() {
            clearMap();
        }
        
        // --- APPLICATION INITIALIZER ---
        function initializeApp() {
            const targetingBtn = document.getElementById('targeting-btn');
            const launchBtn = document.getElementById('launch-btn');
            const saveBtn = document.getElementById('save-btn');
            const resetBtn = document.getElementById('reset-btn');
            const clearBtn = document.getElementById('clear-btn');
            const mapDropEl = document.getElementById('map');

            targetingBtn.addEventListener('click', () => {
                const isAlreadyTargeting = activeAction.type === 'targeting';
                setAction(isAlreadyTargeting ? null : 'targeting');
            });
            launchBtn.addEventListener('click', launchAllTargeted);

            saveBtn.addEventListener('click', () => {
                savedScenario = Array.from(activeMapUnits.values()).map(unit => ({
                    latlng: unit.marker.getLatLng(),
                    unitId: unit.unitId,
                    instanceId: unit.instanceId,
                    ammo: unit.ammo,
                    mountedWeapons: unit.mountedWeapons ? unit.mountedWeapons.map(w => ({ weaponId: w.weaponId, ammo: w.ammo, instanceId: w.instanceId })) : null,
                    destination: unit.destination
                }));
                saveBtn.textContent = "Saved!";
                saveBtn.classList.replace('bg-indigo-600', 'bg-green-500');
                saveBtn.classList.remove('hover:bg-indigo-700');
                setTimeout(() => {
                    saveBtn.textContent = "Save State";
                    saveBtn.classList.replace('bg-green-500', 'bg-indigo-600');
                    saveBtn.classList.add('hover:bg-indigo-700');
                }, 1500);
            });

            resetBtn.addEventListener('click', () => {
                clearMap();
                if (savedScenario) {
                    const maxId = savedScenario.reduce((max, unit) => {
                        let highestId = unit.instanceId;
                        if (unit.mountedWeapons) {
                            const maxWeaponId = unit.mountedWeapons.reduce((wm, w) => Math.max(wm, w.instanceId), 0);
                            highestId = Math.max(highestId, maxWeaponId);
                        }
                        return Math.max(max, highestId);
                    }, -1);
                    nextUnitInstanceId = maxId + 1;

                    savedScenario.forEach(unit => {
                        addCapability(unit.latlng, unit.unitId, unit.instanceId, unit.ammo, unit.mountedWeapons, unit.destination);
                    });
                } else {
                    setupInitialScene();
                }
            });
            
            clearBtn.addEventListener('click', clearMap);
            
            mapDropEl.addEventListener('dragover', e => e.preventDefault());
            mapDropEl.addEventListener('drop', e => {
                e.preventDefault();
                const unitId = e.dataTransfer.getData('text/plain');
                const unitData = unitLibrary[unitId];
                if (!unitData || unitData.platform === 'aircraft') return;
                const mapRect = mapDropEl.getBoundingClientRect();
                const latLng = map.containerPointToLatLng([e.clientX - mapRect.left, e.clientY - mapRect.top]);
                addCapability(latLng, unitId);
            });

            map.on('click', e => {
                if (activeAction.type === 'targeting') {
                    setTarget(null, e.latlng);
                } else if (activeAction.type === 'move') {
                    let moved = false;
                    activeMapUnits.forEach(unit => {
                        const el = unit.marker.getElement();
                        if (el && el.style.filter) {
                            unit.destination = e.latlng;
                            if (unit.movePathLine) unit.movePathLine.remove();
                            unit.movePathLine = L.polyline([unit.marker.getLatLng(), unit.destination], { color: 'green', weight: 2, className: 'move-path-line' }).addTo(map);
                            moved = true;
                        }
                    });
                    if (moved) setAction(null);
                } else {
                    if (activeInfoPopup) {
                        map.closePopup(activeInfoPopup);
                        activeInfoPopup = null;
                    }
                }
            });

            // --- LEGEND INITIALIZATION ---
            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info legend');
                const grades = [
                    {style: ringStyles.sensor, label: 'Sensor Range'},
                    {style: ringStyles.movement, label: 'Movement Range'},
                    {style: ringStyles.ea, label: 'Electronic Attack'},
                    {style: ringStyles.weapon, label: 'Weapon Range'},
                ];
                let legendHtml = '<h4>Range Types</h4>';
                for (let i = 0; i < grades.length; i++) {
                    legendHtml +=
                        '<i style="background:' + grades[i].style.color + '; border: 1px solid ' + grades[i].style.color + '"></i> ' +
                        grades[i].label + '<br>';
                }
                div.innerHTML = legendHtml;
                return div;
            };
            legend.addTo(map);

            // --- DELEGATED EVENT LISTENERS ---
            document.body.addEventListener('click', e => {
                const button = e.target.closest('[data-action]');
                if (!button) return;

                const { action, unitId, weaponId } = button.dataset;
                const id = parseInt(unitId);
                
                if (action === 'delete') {
                    deleteUnit(id);
                }
                if (action === 'unmount') {
                    unmountWeaponFromAircraft(id, parseInt(weaponId));
                }
            });

            // --- STARTUP ---
            populateMenu();
            setupInitialScene();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>
